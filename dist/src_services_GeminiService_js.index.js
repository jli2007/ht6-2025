"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkcom_adobe_uxp_starter_react"] = self["webpackChunkcom_adobe_uxp_starter_react"] || []).push([["src_services_GeminiService_js"],{

/***/ "./src/services/GeminiService.js":
/*!***************************************!*\
  !*** ./src/services/GeminiService.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GeminiService: () => (/* binding */ GeminiService)\n/* harmony export */ });\n/**\n * Gemini Service for generating CSS-like Photoshop adjustments\n */\n\nclass GeminiService {\n  constructor(apiKey = null) {\n    // Use provided API key or fall back to environment variable\n    this.apiKey = apiKey || process.env.GEMINI_API_KEY;\n    this.baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent';\n    if (!this.apiKey) {\n      throw new Error('Gemini API key not found. Please set GEMINI_API_KEY in your .env file or provide it as a parameter.');\n    }\n  }\n\n  /**\n   * Generate CSS-like code from a text description\n   */\n  async generateCSS(prompt) {\n    try {\n      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          contents: [{\n            parts: [{\n              text: this.buildPrompt(prompt)\n            }]\n          }]\n        })\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('API Error Response:', errorText);\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      console.log('Gemini API Response:', data);\n      if (data.candidates && data.candidates[0] && data.candidates[0].content) {\n        const generatedText = data.candidates[0].content.parts[0].text;\n        return this.extractCSSFromResponse(generatedText);\n      } else {\n        throw new Error('No valid response from Gemini API');\n      }\n    } catch (error) {\n      console.error('Error generating CSS:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Build the prompt for Gemini - focused on exactness and controllability\n   */\n  buildPrompt(userPrompt) {\n    return `You are an expert Photoshop adjustment generator. Your job is to convert inexact, vague descriptions into precise, controllable CSS-like recipes that can be applied to Photoshop layers.\n\nUser request: \"${userPrompt}\"\n\nYour task is to solve the \"exactness\" problem by translating this messy input into a clean, precise recipe.\n\nGenerate CSS-like code using these supported properties:\n- contrast: percentage (e.g., 120%, -20%)\n- saturation: percentage (e.g., 150%, -50%)\n- brightness: percentage (e.g., 105%, -10%)\n- hue: degrees (e.g., 15deg, -30deg)\n- blur: pixels (e.g., 2px, 0.5px)\n- opacity: percentage (e.g., 85%, 100%)\n- levels: \"shadows, midtones, highlights\" (e.g., \"0, 1.2, 255\")\n- vibrance: percentage (e.g., 25%, -15%)\n- shadows: percentage (e.g., 20%, -10%)\n- highlights: percentage (e.g., -15%, 25%)\n\nRules for exactness:\n1. Use realistic, precise values that would create the described effect\n2. Think like a professional colorist - be specific about the adjustments\n3. Include comments explaining your choices\n4. Return ONLY the CSS-like code, no other text\n5. Use the .layer selector\n6. Keep it concise but effective\n7. Make it easily editable by the user\n\nExample output format:\n/* CSS-like Photoshop adjustments for: ${userPrompt} */\n.layer {\n    contrast: 120%;\n    saturation: -20%;\n    brightness: 105%;\n    hue: 15deg;\n    blur: 2px;\n    opacity: 85%;\n}\n\nNow generate a precise, controllable recipe for: \"${userPrompt}\"`;\n  }\n\n  /**\n   * Extract CSS code from Gemini's response\n   */\n  extractCSSFromResponse(response) {\n    console.log('Extracting CSS from response:', response);\n\n    // Look for CSS-like code blocks\n    const cssMatch = response.match(/```(?:css)?\\s*([\\s\\S]*?)\\s*```/);\n    if (cssMatch) {\n      return cssMatch[1].trim();\n    }\n\n    // Look for CSS-like code without code blocks\n    const cssPattern = /\\.layer\\s*\\{[\\s\\S]*?\\}/;\n    const match = response.match(cssPattern);\n    if (match) {\n      return match[0];\n    }\n\n    // If no CSS found, return a basic template\n    return `/* Generated CSS for: ${response} */\n.layer {\n    contrast: 100%;\n    saturation: 0%;\n    brightness: 100%;\n}`;\n  }\n\n  /**\n   * Generate CSS from an image (using Gemini Vision API)\n   */\n  async generateCSSFromImage(imageData, description = \"\") {\n    try {\n      // Convert image data to base64 if it's a data URL\n      let base64Data;\n      if (imageData.startsWith('data:')) {\n        base64Data = imageData.split(',')[1];\n      } else {\n        base64Data = await this.imageToBase64(imageData);\n      }\n      const response = await fetch(`${this.baseUrl}?key=${this.apiKey}`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({\n          contents: [{\n            parts: [{\n              text: this.buildImagePrompt(description)\n            }, {\n              inline_data: {\n                mime_type: \"image/jpeg\",\n                data: base64Data\n              }\n            }]\n          }]\n        })\n      });\n      if (!response.ok) {\n        const errorText = await response.text();\n        console.error('API Error Response:', errorText);\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n      const data = await response.json();\n      console.log('Gemini API Response:', data);\n      if (data.candidates && data.candidates[0] && data.candidates[0].content) {\n        const generatedText = data.candidates[0].content.parts[0].text;\n        return this.extractCSSFromResponse(generatedText);\n      } else {\n        throw new Error('No valid response from Gemini API');\n      }\n    } catch (error) {\n      console.error('Error generating CSS from image:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Build prompt for image-based generation - focused on exactness\n   */\n  buildImagePrompt(description) {\n    return `You are an expert Photoshop adjustment generator. Analyze this image and generate a precise, controllable CSS-like recipe that would recreate its visual style.\n\n${description ? `Additional context: \"${description}\"` : ''}\n\nYour job is to solve the \"exactness\" problem by translating this visual inspiration into a precise, editable recipe.\n\nGenerate CSS-like code using these supported properties:\n- contrast: percentage (e.g., 120%, -20%)\n- saturation: percentage (e.g., 150%, -50%)\n- brightness: percentage (e.g., 105%, -10%)\n- hue: degrees (e.g., 15deg, -30deg)\n- blur: pixels (e.g., 2px, 0.5px)\n- opacity: percentage (e.g., 85%, 100%)\n- levels: \"shadows, midtones, highlights\" (e.g., \"0, 1.2, 255\")\n- vibrance: percentage (e.g., 25%, -15%)\n- shadows: percentage (e.g., 20%, -10%)\n- highlights: percentage (e.g., -15%, 25%)\n\nAnalyze the image's:\n- Color temperature and hue shifts\n- Contrast and brightness levels\n- Saturation and vibrance characteristics\n- Overall mood and style\n- Any special effects or filters\n\nThink like a professional colorist and provide precise, controllable values that the user can fine-tune.\n\nReturn ONLY the CSS-like code, no other text. Use the .layer selector. Make it easily editable.`;\n  }\n\n  /**\n   * Convert image URL to base64 (for API calls)\n   */\n  async imageToBase64(imageUrl) {\n    try {\n      const response = await fetch(imageUrl);\n      const blob = await response.blob();\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onloadend = () => {\n          const base64 = reader.result.split(',')[1];\n          resolve(base64);\n        };\n        reader.onerror = reject;\n        reader.readAsDataURL(blob);\n      });\n    } catch (error) {\n      console.error('Error converting image to base64:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Test the API connection\n   */\n  async testConnection() {\n    try {\n      const response = await this.generateCSS(\"test\");\n      return response && response.length > 0;\n    } catch (error) {\n      console.error('API connection test failed:', error);\n      return false;\n    }\n  }\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvc2VydmljZXMvR2VtaW5pU2VydmljZS5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL2NvbS5hZG9iZS51eHAuc3RhcnRlci5yZWFjdC8uL3NyYy9zZXJ2aWNlcy9HZW1pbmlTZXJ2aWNlLmpzP2U1ZjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHZW1pbmkgU2VydmljZSBmb3IgZ2VuZXJhdGluZyBDU1MtbGlrZSBQaG90b3Nob3AgYWRqdXN0bWVudHNcbiAqL1xuXG5leHBvcnQgY2xhc3MgR2VtaW5pU2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKGFwaUtleSA9IG51bGwpIHtcbiAgICAvLyBVc2UgcHJvdmlkZWQgQVBJIGtleSBvciBmYWxsIGJhY2sgdG8gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleSB8fCBwcm9jZXNzLmVudi5HRU1JTklfQVBJX0tFWTtcbiAgICB0aGlzLmJhc2VVcmwgPSAnaHR0cHM6Ly9nZW5lcmF0aXZlbGFuZ3VhZ2UuZ29vZ2xlYXBpcy5jb20vdjFiZXRhL21vZGVscy9nZW1pbmktMi41LXBybzpnZW5lcmF0ZUNvbnRlbnQnO1xuICAgIGlmICghdGhpcy5hcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignR2VtaW5pIEFQSSBrZXkgbm90IGZvdW5kLiBQbGVhc2Ugc2V0IEdFTUlOSV9BUElfS0VZIGluIHlvdXIgLmVudiBmaWxlIG9yIHByb3ZpZGUgaXQgYXMgYSBwYXJhbWV0ZXIuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIENTUy1saWtlIGNvZGUgZnJvbSBhIHRleHQgZGVzY3JpcHRpb25cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlQ1NTKHByb21wdCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0/a2V5PSR7dGhpcy5hcGlLZXl9YCwge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgICAgfSxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgIGNvbnRlbnRzOiBbe1xuICAgICAgICAgICAgcGFydHM6IFt7XG4gICAgICAgICAgICAgIHRleHQ6IHRoaXMuYnVpbGRQcm9tcHQocHJvbXB0KVxuICAgICAgICAgICAgfV1cbiAgICAgICAgICB9XVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IGVycm9yVGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgY29uc29sZS5lcnJvcignQVBJIEVycm9yIFJlc3BvbnNlOicsIGVycm9yVGV4dCk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICBjb25zb2xlLmxvZygnR2VtaW5pIEFQSSBSZXNwb25zZTonLCBkYXRhKTtcbiAgICAgIGlmIChkYXRhLmNhbmRpZGF0ZXMgJiYgZGF0YS5jYW5kaWRhdGVzWzBdICYmIGRhdGEuY2FuZGlkYXRlc1swXS5jb250ZW50KSB7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRlZFRleHQgPSBkYXRhLmNhbmRpZGF0ZXNbMF0uY29udGVudC5wYXJ0c1swXS50ZXh0O1xuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0Q1NTRnJvbVJlc3BvbnNlKGdlbmVyYXRlZFRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyB2YWxpZCByZXNwb25zZSBmcm9tIEdlbWluaSBBUEknKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2VuZXJhdGluZyBDU1M6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHRoZSBwcm9tcHQgZm9yIEdlbWluaSAtIGZvY3VzZWQgb24gZXhhY3RuZXNzIGFuZCBjb250cm9sbGFiaWxpdHlcbiAgICovXG4gIGJ1aWxkUHJvbXB0KHVzZXJQcm9tcHQpIHtcbiAgICByZXR1cm4gYFlvdSBhcmUgYW4gZXhwZXJ0IFBob3Rvc2hvcCBhZGp1c3RtZW50IGdlbmVyYXRvci4gWW91ciBqb2IgaXMgdG8gY29udmVydCBpbmV4YWN0LCB2YWd1ZSBkZXNjcmlwdGlvbnMgaW50byBwcmVjaXNlLCBjb250cm9sbGFibGUgQ1NTLWxpa2UgcmVjaXBlcyB0aGF0IGNhbiBiZSBhcHBsaWVkIHRvIFBob3Rvc2hvcCBsYXllcnMuXG5cblVzZXIgcmVxdWVzdDogXCIke3VzZXJQcm9tcHR9XCJcblxuWW91ciB0YXNrIGlzIHRvIHNvbHZlIHRoZSBcImV4YWN0bmVzc1wiIHByb2JsZW0gYnkgdHJhbnNsYXRpbmcgdGhpcyBtZXNzeSBpbnB1dCBpbnRvIGEgY2xlYW4sIHByZWNpc2UgcmVjaXBlLlxuXG5HZW5lcmF0ZSBDU1MtbGlrZSBjb2RlIHVzaW5nIHRoZXNlIHN1cHBvcnRlZCBwcm9wZXJ0aWVzOlxuLSBjb250cmFzdDogcGVyY2VudGFnZSAoZS5nLiwgMTIwJSwgLTIwJSlcbi0gc2F0dXJhdGlvbjogcGVyY2VudGFnZSAoZS5nLiwgMTUwJSwgLTUwJSlcbi0gYnJpZ2h0bmVzczogcGVyY2VudGFnZSAoZS5nLiwgMTA1JSwgLTEwJSlcbi0gaHVlOiBkZWdyZWVzIChlLmcuLCAxNWRlZywgLTMwZGVnKVxuLSBibHVyOiBwaXhlbHMgKGUuZy4sIDJweCwgMC41cHgpXG4tIG9wYWNpdHk6IHBlcmNlbnRhZ2UgKGUuZy4sIDg1JSwgMTAwJSlcbi0gbGV2ZWxzOiBcInNoYWRvd3MsIG1pZHRvbmVzLCBoaWdobGlnaHRzXCIgKGUuZy4sIFwiMCwgMS4yLCAyNTVcIilcbi0gdmlicmFuY2U6IHBlcmNlbnRhZ2UgKGUuZy4sIDI1JSwgLTE1JSlcbi0gc2hhZG93czogcGVyY2VudGFnZSAoZS5nLiwgMjAlLCAtMTAlKVxuLSBoaWdobGlnaHRzOiBwZXJjZW50YWdlIChlLmcuLCAtMTUlLCAyNSUpXG5cblJ1bGVzIGZvciBleGFjdG5lc3M6XG4xLiBVc2UgcmVhbGlzdGljLCBwcmVjaXNlIHZhbHVlcyB0aGF0IHdvdWxkIGNyZWF0ZSB0aGUgZGVzY3JpYmVkIGVmZmVjdFxuMi4gVGhpbmsgbGlrZSBhIHByb2Zlc3Npb25hbCBjb2xvcmlzdCAtIGJlIHNwZWNpZmljIGFib3V0IHRoZSBhZGp1c3RtZW50c1xuMy4gSW5jbHVkZSBjb21tZW50cyBleHBsYWluaW5nIHlvdXIgY2hvaWNlc1xuNC4gUmV0dXJuIE9OTFkgdGhlIENTUy1saWtlIGNvZGUsIG5vIG90aGVyIHRleHRcbjUuIFVzZSB0aGUgLmxheWVyIHNlbGVjdG9yXG42LiBLZWVwIGl0IGNvbmNpc2UgYnV0IGVmZmVjdGl2ZVxuNy4gTWFrZSBpdCBlYXNpbHkgZWRpdGFibGUgYnkgdGhlIHVzZXJcblxuRXhhbXBsZSBvdXRwdXQgZm9ybWF0OlxuLyogQ1NTLWxpa2UgUGhvdG9zaG9wIGFkanVzdG1lbnRzIGZvcjogJHt1c2VyUHJvbXB0fSAqL1xuLmxheWVyIHtcbiAgICBjb250cmFzdDogMTIwJTtcbiAgICBzYXR1cmF0aW9uOiAtMjAlO1xuICAgIGJyaWdodG5lc3M6IDEwNSU7XG4gICAgaHVlOiAxNWRlZztcbiAgICBibHVyOiAycHg7XG4gICAgb3BhY2l0eTogODUlO1xufVxuXG5Ob3cgZ2VuZXJhdGUgYSBwcmVjaXNlLCBjb250cm9sbGFibGUgcmVjaXBlIGZvcjogXCIke3VzZXJQcm9tcHR9XCJgO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3QgQ1NTIGNvZGUgZnJvbSBHZW1pbmkncyByZXNwb25zZVxuICAgKi9cbiAgZXh0cmFjdENTU0Zyb21SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIENTUyBmcm9tIHJlc3BvbnNlOicsIHJlc3BvbnNlKTtcblxuICAgIC8vIExvb2sgZm9yIENTUy1saWtlIGNvZGUgYmxvY2tzXG4gICAgY29uc3QgY3NzTWF0Y2ggPSByZXNwb25zZS5tYXRjaCgvYGBgKD86Y3NzKT9cXHMqKFtcXHNcXFNdKj8pXFxzKmBgYC8pO1xuICAgIGlmIChjc3NNYXRjaCkge1xuICAgICAgcmV0dXJuIGNzc01hdGNoWzFdLnRyaW0oKTtcbiAgICB9XG5cbiAgICAvLyBMb29rIGZvciBDU1MtbGlrZSBjb2RlIHdpdGhvdXQgY29kZSBibG9ja3NcbiAgICBjb25zdCBjc3NQYXR0ZXJuID0gL1xcLmxheWVyXFxzKlxce1tcXHNcXFNdKj9cXH0vO1xuICAgIGNvbnN0IG1hdGNoID0gcmVzcG9uc2UubWF0Y2goY3NzUGF0dGVybik7XG4gICAgaWYgKG1hdGNoKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMF07XG4gICAgfVxuXG4gICAgLy8gSWYgbm8gQ1NTIGZvdW5kLCByZXR1cm4gYSBiYXNpYyB0ZW1wbGF0ZVxuICAgIHJldHVybiBgLyogR2VuZXJhdGVkIENTUyBmb3I6ICR7cmVzcG9uc2V9ICovXG4ubGF5ZXIge1xuICAgIGNvbnRyYXN0OiAxMDAlO1xuICAgIHNhdHVyYXRpb246IDAlO1xuICAgIGJyaWdodG5lc3M6IDEwMCU7XG59YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBDU1MgZnJvbSBhbiBpbWFnZSAodXNpbmcgR2VtaW5pIFZpc2lvbiBBUEkpXG4gICAqL1xuICBhc3luYyBnZW5lcmF0ZUNTU0Zyb21JbWFnZShpbWFnZURhdGEsIGRlc2NyaXB0aW9uID0gXCJcIikge1xuICAgIHRyeSB7XG4gICAgICAvLyBDb252ZXJ0IGltYWdlIGRhdGEgdG8gYmFzZTY0IGlmIGl0J3MgYSBkYXRhIFVSTFxuICAgICAgbGV0IGJhc2U2NERhdGE7XG4gICAgICBpZiAoaW1hZ2VEYXRhLnN0YXJ0c1dpdGgoJ2RhdGE6JykpIHtcbiAgICAgICAgYmFzZTY0RGF0YSA9IGltYWdlRGF0YS5zcGxpdCgnLCcpWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFzZTY0RGF0YSA9IGF3YWl0IHRoaXMuaW1hZ2VUb0Jhc2U2NChpbWFnZURhdGEpO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHt0aGlzLmJhc2VVcmx9P2tleT0ke3RoaXMuYXBpS2V5fWAsIHtcbiAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gICAgICAgIH0sXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICBjb250ZW50czogW3tcbiAgICAgICAgICAgIHBhcnRzOiBbe1xuICAgICAgICAgICAgICB0ZXh0OiB0aGlzLmJ1aWxkSW1hZ2VQcm9tcHQoZGVzY3JpcHRpb24pXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgIGlubGluZV9kYXRhOiB7XG4gICAgICAgICAgICAgICAgbWltZV90eXBlOiBcImltYWdlL2pwZWdcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBiYXNlNjREYXRhXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1dXG4gICAgICAgICAgfV1cbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICBjb25zdCBlcnJvclRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvciBSZXNwb25zZTonLCBlcnJvclRleHQpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEhUVFAgZXJyb3IhIHN0YXR1czogJHtyZXNwb25zZS5zdGF0dXN9YCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgY29uc29sZS5sb2coJ0dlbWluaSBBUEkgUmVzcG9uc2U6JywgZGF0YSk7XG4gICAgICBpZiAoZGF0YS5jYW5kaWRhdGVzICYmIGRhdGEuY2FuZGlkYXRlc1swXSAmJiBkYXRhLmNhbmRpZGF0ZXNbMF0uY29udGVudCkge1xuICAgICAgICBjb25zdCBnZW5lcmF0ZWRUZXh0ID0gZGF0YS5jYW5kaWRhdGVzWzBdLmNvbnRlbnQucGFydHNbMF0udGV4dDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdENTU0Zyb21SZXNwb25zZShnZW5lcmF0ZWRUZXh0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gdmFsaWQgcmVzcG9uc2UgZnJvbSBHZW1pbmkgQVBJJyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdlbmVyYXRpbmcgQ1NTIGZyb20gaW1hZ2U6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIHByb21wdCBmb3IgaW1hZ2UtYmFzZWQgZ2VuZXJhdGlvbiAtIGZvY3VzZWQgb24gZXhhY3RuZXNzXG4gICAqL1xuICBidWlsZEltYWdlUHJvbXB0KGRlc2NyaXB0aW9uKSB7XG4gICAgcmV0dXJuIGBZb3UgYXJlIGFuIGV4cGVydCBQaG90b3Nob3AgYWRqdXN0bWVudCBnZW5lcmF0b3IuIEFuYWx5emUgdGhpcyBpbWFnZSBhbmQgZ2VuZXJhdGUgYSBwcmVjaXNlLCBjb250cm9sbGFibGUgQ1NTLWxpa2UgcmVjaXBlIHRoYXQgd291bGQgcmVjcmVhdGUgaXRzIHZpc3VhbCBzdHlsZS5cblxuJHtkZXNjcmlwdGlvbiA/IGBBZGRpdGlvbmFsIGNvbnRleHQ6IFwiJHtkZXNjcmlwdGlvbn1cImAgOiAnJ31cblxuWW91ciBqb2IgaXMgdG8gc29sdmUgdGhlIFwiZXhhY3RuZXNzXCIgcHJvYmxlbSBieSB0cmFuc2xhdGluZyB0aGlzIHZpc3VhbCBpbnNwaXJhdGlvbiBpbnRvIGEgcHJlY2lzZSwgZWRpdGFibGUgcmVjaXBlLlxuXG5HZW5lcmF0ZSBDU1MtbGlrZSBjb2RlIHVzaW5nIHRoZXNlIHN1cHBvcnRlZCBwcm9wZXJ0aWVzOlxuLSBjb250cmFzdDogcGVyY2VudGFnZSAoZS5nLiwgMTIwJSwgLTIwJSlcbi0gc2F0dXJhdGlvbjogcGVyY2VudGFnZSAoZS5nLiwgMTUwJSwgLTUwJSlcbi0gYnJpZ2h0bmVzczogcGVyY2VudGFnZSAoZS5nLiwgMTA1JSwgLTEwJSlcbi0gaHVlOiBkZWdyZWVzIChlLmcuLCAxNWRlZywgLTMwZGVnKVxuLSBibHVyOiBwaXhlbHMgKGUuZy4sIDJweCwgMC41cHgpXG4tIG9wYWNpdHk6IHBlcmNlbnRhZ2UgKGUuZy4sIDg1JSwgMTAwJSlcbi0gbGV2ZWxzOiBcInNoYWRvd3MsIG1pZHRvbmVzLCBoaWdobGlnaHRzXCIgKGUuZy4sIFwiMCwgMS4yLCAyNTVcIilcbi0gdmlicmFuY2U6IHBlcmNlbnRhZ2UgKGUuZy4sIDI1JSwgLTE1JSlcbi0gc2hhZG93czogcGVyY2VudGFnZSAoZS5nLiwgMjAlLCAtMTAlKVxuLSBoaWdobGlnaHRzOiBwZXJjZW50YWdlIChlLmcuLCAtMTUlLCAyNSUpXG5cbkFuYWx5emUgdGhlIGltYWdlJ3M6XG4tIENvbG9yIHRlbXBlcmF0dXJlIGFuZCBodWUgc2hpZnRzXG4tIENvbnRyYXN0IGFuZCBicmlnaHRuZXNzIGxldmVsc1xuLSBTYXR1cmF0aW9uIGFuZCB2aWJyYW5jZSBjaGFyYWN0ZXJpc3RpY3Ncbi0gT3ZlcmFsbCBtb29kIGFuZCBzdHlsZVxuLSBBbnkgc3BlY2lhbCBlZmZlY3RzIG9yIGZpbHRlcnNcblxuVGhpbmsgbGlrZSBhIHByb2Zlc3Npb25hbCBjb2xvcmlzdCBhbmQgcHJvdmlkZSBwcmVjaXNlLCBjb250cm9sbGFibGUgdmFsdWVzIHRoYXQgdGhlIHVzZXIgY2FuIGZpbmUtdHVuZS5cblxuUmV0dXJuIE9OTFkgdGhlIENTUy1saWtlIGNvZGUsIG5vIG90aGVyIHRleHQuIFVzZSB0aGUgLmxheWVyIHNlbGVjdG9yLiBNYWtlIGl0IGVhc2lseSBlZGl0YWJsZS5gO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnQgaW1hZ2UgVVJMIHRvIGJhc2U2NCAoZm9yIEFQSSBjYWxscylcbiAgICovXG4gIGFzeW5jIGltYWdlVG9CYXNlNjQoaW1hZ2VVcmwpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChpbWFnZVVybCk7XG4gICAgICBjb25zdCBibG9iID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCBiYXNlNjQgPSByZWFkZXIucmVzdWx0LnNwbGl0KCcsJylbMV07XG4gICAgICAgICAgcmVzb2x2ZShiYXNlNjQpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoYmxvYik7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29udmVydGluZyBpbWFnZSB0byBiYXNlNjQ6JywgZXJyb3IpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRlc3QgdGhlIEFQSSBjb25uZWN0aW9uXG4gICAqL1xuICBhc3luYyB0ZXN0Q29ubmVjdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdlbmVyYXRlQ1NTKFwidGVzdFwiKTtcbiAgICAgIHJldHVybiByZXNwb25zZSAmJiByZXNwb25zZS5sZW5ndGggPiAwO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdBUEkgY29ubmVjdGlvbiB0ZXN0IGZhaWxlZDonLCBlcnJvcik7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/services/GeminiService.js\n\n}");

/***/ })

}]);